PROBLEM STATEMENT: 1

ğŸ“Œ Patterns Covered
1. Strategy Pattern â€“ Dynamic Discounts

File: strategy.ts

Use Case: Apply different discount strategies (percentage or flat amount) to coffee orders.

Why: The discount calculation algorithm can change at runtime.

Example:

15% off â†’ Final price: $85.00

Flat $20 off â†’ Final price: $80.00

2. Observer Pattern â€“ Stock/Price Notifications

File: observer.ts

Use Case: Apps (observers) get notified automatically when stock price changes.

Why: Keeps multiple subscribers updated without tightly coupling them.

Example:

Price crosses $105 â†’ Observers suggest â€œSellâ€.

Price stays low â†’ Observers keep â€œMonitoringâ€.

3. Factory Method Pattern â€“ Invoice Generation

File: factory.ts

Use Case: Generate invoices in different formats (PDF, HTML).

Why: Client code only requests a document, the factory decides which one to produce.

Example:

PDF Invoice â†’ â€œRendering PDF document (formatted for print).â€

HTML Invoice â†’ â€œRendering HTML document (formatted for web).â€

4. Singleton Pattern â€“ Global Configuration

File: singleton.ts

Use Case: Only one instance of configuration manager exists, shared across the app.

Why: Centralized access to settings like DB connection, tax rates, thread limits.

Example:

config1 and config2 both point to the same object.

Updating one updates the other.

5. Adapter Pattern â€“ Legacy Payment Integration

File: adapter.ts

Use Case: Modern app expects login(username, token) but legacy system uses authenticateUser(username, passwordHash).

Why: Bridges incompatible interfaces without rewriting old code.

Example:

Modern app calls â†’ Adapter translates â†’ Legacy system executes.

6. Decorator Pattern â€“ Coffee Add-ons

File: decorator.ts

Use Case: Start with a simple coffee and dynamically add extras (Milk, Extra Shot).

Why: Add responsibilities at runtime without modifying the base class.

Example:

Simple Coffee ($5)

Milk (+$1.50)

Extra Shot (+$2.00)

ğŸš€ main.ts â€“ Coffee Shop Simulator (All 6 usecases Together)

The console-based application ties all six patterns into a single Coffee Shop domain:

Decorator â†’ Build your coffee (Simple, add Milk, add Extra Shot).

Strategy â†’ Apply a discount (percentage or flat).

Observer â†’ Notify manager when a high-value order is placed.

Factory â†’ Generate invoice (PDF/HTML).

Adapter â†’ Process payment via legacy system.

Singleton â†’ Global configuration (e.g., tax rate).

Sample Flow:
=== Welcome to Coffee Shop Simulator ===

Add Milk? (y/n): y
Add Extra Shot? (y/n): y
Order: Simple Coffee, Milk, Extra Shot, Base Cost: $8.50

Discount type (percentage/flat): percentage
Enter discount %: 10
Price after discount: $7.65

[Manager] Notification: High value order placed!
Invoice type (pdf/html): pdf
PDF Invoice generated
Legacy Payment processed: $7.65
Tax Rate from Config: 0.05

ğŸ› ï¸ Tech Stack

Language: TypeScript

Runtime: Node.js with ts-node

Input: Console (readline)

How to run : npx ts-node first_usecase/<filename>.ts
